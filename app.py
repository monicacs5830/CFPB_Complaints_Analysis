# -*- coding: utf-8 -*-
"""Data 608_FinalProject_V2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mxVhx-o0WNKgx9GpHahEZzpg7RaroNFB
"""

#!pip install gcsfs
#!pip install google-cloud-bigquery
#
#!pip install db-dtypes
#
#!pip install dash-bootstrap-components
#
#!pip install dash
#
#!pip install gcsfs

# importing the necessary libraries for data manipulation and visualization
from google.cloud import bigquery
import gcsfs
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import dash
from dash import dcc
from dash import html
import dash_bootstrap_components as dbc
from dash import dash_table
from dash.dependencies import Input, Output, State
import random
import plotly.express as px

# Authenticating with the Google Cloud account and setting up the BigQuery client:
import os
import subprocess

# URL to the raw GitHub file
url = "https://raw.githubusercontent.com/monicacs5830/CFPB_Complaints_Analysis/main/data608-391503-e77b21b1d01c.json"

# Use wget to download the file
subprocess.run(["wget", url, "-O", "key.json"])

# Set the environment variable
os.environ['GOOGLE_APPLICATION_CREDENTIALS'] = './key.json'

# Now you can create your BigQuery client
client = bigquery.Client()

# Accessing the data:
dataset_ref = client.dataset("cfpb_complaints", project="bigquery-public-data")
cfpb_complaints_table = dataset_ref.table('complaint_database')
# df_complaints = client.get_table(cfpb_complaints_table)

# # Using BigQuery to pull data into a Pandas DataFrame for initial exploration
# query = """
# SELECT *
# FROM `bigquery-public-data.cfpb_complaints.complaint_database`
# LIMIT 1000
# """
# #
# df_complaints = client.query(query).to_dataframe()
# df_complaints.head()

# list of columns to check for nulls
columns_to_check = [
    "subissue",
    "subproduct",
    "consumer_complaint_narrative",
    "company_public_response",
    "state",
    "zip_code",
    "tags",
    "consumer_disputed",
    "consumer_consent_provided",
    "company_response_to_consumer"
]

# SQL query string
missing_data_query = ",\n".join(f"COUNTIF({col} IS NULL) AS {col}_missing_count" for col in columns_to_check)


missing_data_query = f"""
SELECT
  {missing_data_query}
FROM `bigquery-public-data.cfpb_complaints.complaint_database`
"""

# querying the data
missing_data = client.query(missing_data_query).to_dataframe()

# printing the data
print(missing_data)

# 1.How are complaints distributed by product and sub-product?
#Is there any variation in this distribution by state?

# Query for product counts
query_product_counts = """
    SELECT product, COUNT(product) as Counts_Complaints
    FROM `bigquery-public-data.cfpb_complaints.complaint_database`
    WHERE subproduct IS NOT NULL
    GROUP BY product
    ORDER BY Counts_Complaints DESC
    LIMIT 10
"""
query_job_product_counts = client.query(query_product_counts)
products_df_pandas = query_job_product_counts.to_dataframe()

# Get the unique products that have a subproduct associated with them
products = products_df_pandas['product'].unique().tolist()

# Now we ensure the products and subproducts are sorted in descending order
# by complaint count and that we only include products with subproducts.
query1a = """
    SELECT product, subproduct, state, COUNT(state) as Counts_Complaints
    FROM `bigquery-public-data.cfpb_complaints.complaint_database`
    WHERE subproduct IS NOT NULL
    GROUP BY product, subproduct, state
    ORDER BY COUNT(state) DESC
"""
# Execute the query
query_job = client.query(query1a)
product_subproduct_state_df = query_job.to_dataframe()

# Get the mapping from product to subproduct
product_to_subproduct = product_subproduct_state_df.groupby('product')['subproduct'].unique().apply(list).to_dict()

# Get the mapping from product to subproduct
product_to_subproduct = product_subproduct_state_df.groupby('product')['subproduct'].unique().apply(list).to_dict()

abbr_mapping = {
    'Credit reporting, credit repair services, or other personal consumer reports': 'CR, CRS, or OPC Reports',
    'Debt collection': 'Debt Collection',
    'Mortgage': 'Mortgage',
    'Credit card or prepaid card': 'CC or PC',
    'Checking or savings account': 'CoSA',
    'Credit reporting': 'Credit Reporting',
    'Credit card': 'Credit Card',
    'Bank account or service': 'BAS',
    'Student loan': 'Student Loan',
    'Money transfer, virtual currency, or money service': 'MT, VC, or MS',
    'Vehicle loan or lease': 'VLL',
    'Consumer Loan': 'Consumer Loan',
    'Payday loan, title loan, or personal loan': 'PayL, TL, or PL',
    'Payday loan': 'Payday Loan',
    'Money transfers': 'Money Transfers',
    'Prepaid card': 'Prepaid Card',
    'Other financial service': 'OFS',
    'Virtual currency': 'Virtual Currency'
}

# Apply abbreviation mapping to 'product' column
products_df_pandas['product_abbr'] = products_df_pandas['product'].map(abbr_mapping)

# Import plotly colors
from plotly.express.colors import qualitative

# Plot the graph
fig1a = px.bar(
    products_df_pandas,
    x='product_abbr',
    y='Counts_Complaints',
    color='product',
    #color_discrete_sequence=qualitative.Prism
)
fig1a.update_layout(
    autosize=True,
    title_text = 'Distribution of Complaint Types (Product)'
)

# Query
query2a = """
    SELECT IFNULL(issue, 'Unknown') as issue, COUNT(issue) as count
    FROM `bigquery-public-data.cfpb_complaints.complaint_database`
    GROUP BY issue
    ORDER BY count DESC
"""
# Execute the query
query_job = client.query(query2a)
issue_df = query_job.to_dataframe()

# Query for issue, subissue
query_subissue = """
    SELECT IFNULL(issue, 'Unknown') as issue, IFNULL(subissue, 'Unknown') as subissue, COUNT(issue) as count
    FROM `bigquery-public-data.cfpb_complaints.complaint_database`
    GROUP BY issue, subissue
    HAVING count >= 5
    ORDER BY count DESC
"""
query_job_subissue = client.query(query_subissue)
issue_subissue_df = query_job_subissue.to_dataframe()

# After executing your query
issue_df = issue_df[issue_df['issue'] != 'Unknown']

# Similar for subissues
issue_subissue_df = issue_subissue_df[(issue_subissue_df['issue'] != 'Unknown') & (issue_subissue_df['subissue'] != 'Unknown')]

# Count and sort issues
issue_counts = issue_subissue_df.groupby('issue')['count'].sum()
issue_counts_sorted = issue_counts.sort_values(ascending=False)
issues = issue_counts_sorted.index.tolist()

# Mapping from issue to subissues
issue_to_subissue = issue_subissue_df.groupby('issue')['subissue'].unique().apply(list).reindex(issues).to_dict()

# Get top 10 issues
top_issues = issue_counts_sorted.head(10)

# Filter data for top issues
issue_subissue_df_top = issue_subissue_df[issue_subissue_df['issue'].isin(top_issues.index)].nlargest(15, 'count')

# Abbreviations for issue names
abbreviations = {
    'Incorrect information on your report': 'Incorrect Info on CR',
    'Problem with a credit reporting company\'s investigation into an existing problem': 'CR: Investigation Problem',
    'Improper use of your report': 'Improper Use of CR',
    'Loan modification,collection,foreclosure': 'Loan Modification',
    'Attempts to collect debt not owed': 'Unowed Debt Collection',
    'Loan servicing, payments, escrow account': 'Loan Servicing',
    'Trouble during payment process': 'Payment Trouble',
    'Written notification about debt': 'Debt Notification',
    'Cont\'d attempts collect debt not owed': 'Continued Debt Collection',
    'Incorrect information on credit report': 'Incorrect Credit Info',
    'Managing an account': 'Account Management',
}

# Sorting the DataFrame by count in descending order
issue_subissue_df_top['issue_abbrev'] = issue_subissue_df_top['issue'].map(abbreviations)
issue_subissue_df_top = issue_subissue_df_top.sort_values('count',ascending=False)


# Calculate the total number of complaints
total_complaints = issue_df['count'].sum()

# Calculate the percentage for each complaint
issue_subissue_df_top['percentage'] = issue_subissue_df_top['count'] / total_complaints * 100

# Creating the plot with abbreviations
fig2b = px.bar(issue_subissue_df_top, y='issue_abbrev', x='count', color='subissue',
               title='Top 10 Complaints by Issue and Subissue',
               labels={'count':'Count of Complaints', 'issue_abbrev':'Issue'},
               hover_data=['issue'],
               text='percentage'  # Use the 'percentage' column for the annotations
               )
fig2b.update_traces(texttemplate='%{text:.2f}%', textposition='inside')  # Format the text as a percentage
fig2b.update_layout(yaxis={'categoryorder':'total ascending'})

# fig2b.show()

#3. Submission Method Impact
#Is there any relationship between the method used to submit the complaint
#and the response from the company or the outcome of the dispute?

# Query
query3 = """
    SELECT submitted_via, company_response_to_consumer, COUNT(*) as Count_Response
    FROM `bigquery-public-data.cfpb_complaints.complaint_database`
    GROUP BY submitted_via, company_response_to_consumer
    ORDER BY Count_Response DESC
"""
# Execute the query
query_job = client.query(query3)
method_df_pd = query_job.to_dataframe()

# Calculate the total submissions for each submission method
submission_counts = method_df_pd.groupby('submitted_via')['Count_Response'].sum().reset_index()

# Calculate the total complaints
total_complaints = submission_counts['Count_Response'].sum()

# Add a percentage column to the submission_counts DataFrame
submission_counts['Percentage'] = submission_counts['Count_Response'] / total_complaints * 100

# Plotting the stacked bar chart
fig3 = px.bar(method_df_pd, x='submitted_via', y='Count_Response',
             color='company_response_to_consumer',
             title='Company Responses by Submission Method',
             labels={'Count_Response':'Count of Responses',
                     'submitted_via':'Submission Method',
                     'company_response_to_consumer':'Company Response'})

# Annotating the bars with the calculated percentages
for index, row in submission_counts.iterrows():
    fig3.add_annotation(x=row['submitted_via'], y=row['Count_Response'],
                        text=f"{row['Percentage']:.2f}%",
                        showarrow=False)

# # Show the plot
# fig3.show()

# checking association using contingency table
from scipy.stats import chi2_contingency

# Create a cross-tabulation (contingency table)
contingency_table = pd.crosstab(method_df_pd['submitted_via'], method_df_pd['company_response_to_consumer'])

# Perform the Chi-Square Test of Independence
chi2, p, dof, expected = chi2_contingency(contingency_table)

# Print the results
print("chi2 statistic", chi2)
print("p-value", p)

# Data preparation and plot creation for page 4
# 4a: analyzing total complaints over time
# Query
query4a = """
    SELECT DATE(date_received) as date_received, COUNT(*) as count
    FROM `bigquery-public-data.cfpb_complaints.complaint_database`
    GROUP BY date_received
    ORDER BY date_received
"""
# Execute the query
query_job = client.query(query4a)
complaints_over_time = query_job.to_dataframe()

# Monthly moving average
complaints_over_time['monthly_mva'] = complaints_over_time['count'].rolling(window=30).mean()

# Base line plot
fig4a = go.Figure()
fig4a.add_trace(go.Scatter(x=complaints_over_time['date_received'], y=complaints_over_time['count'],
                           mode='lines', name='Complaints', line=dict(color='#FA9A85', width=0.5, dash='dash')))
fig4a.add_trace(go.Scatter(x=complaints_over_time['date_received'], y=complaints_over_time['monthly_mva'],
                           mode='lines', name='Monthly Moving Average', line=dict(color='darkred', width=2)))
fig4a.update_layout(title='Trend in complaints received over time',
                   xaxis_title='Date Received',
                   yaxis_title='Number of Complaints')

#fig4a.show()

"""### Suggested Feedback"""

query_4f="""WITH total_complaints AS (
    SELECT DATE_TRUNC(date_received, YEAR) as year,
           COUNT(*) as total
    FROM `bigquery-public-data.cfpb_complaints.complaint_database`
    GROUP BY year
),
monetary_complaints AS (
    SELECT DATE_TRUNC(date_received, YEAR) as year,
           COUNT(*) as monetary_relief
    FROM `bigquery-public-data.cfpb_complaints.complaint_database`
    WHERE company_response_to_consumer = 'Closed with monetary relief'
    GROUP BY year
),
non_monetary_complaints AS (
    SELECT DATE_TRUNC(date_received, YEAR) as year,
           COUNT(*) as non_monetary_relief
    FROM `bigquery-public-data.cfpb_complaints.complaint_database`
    WHERE company_response_to_consumer = 'Closed with non-monetary relief'
    GROUP BY year
)
SELECT t.year,
       m.monetary_relief / t.total as proportion_monetary,
       n.non_monetary_relief / t.total as proportion_non_monetary
FROM total_complaints t
JOIN monetary_complaints m ON t.year = m.year
JOIN non_monetary_complaints n ON t.year = n.year
ORDER BY t.year
"""
query_job_4f = client.query(query_4f)
resolution_per_complaint_df = query_job_4f.to_dataframe()
resolution_per_complaint_df['year'] = pd.to_datetime(resolution_per_complaint_df['year'])
fig4f = go.Figure()

# Plotting proportion of complaints closed with monetary relief
fig4f.add_trace(go.Scatter(x=resolution_per_complaint_df['year'],
                           y=resolution_per_complaint_df['proportion_monetary'],
                           mode='lines',
                           name='Monetary Relief'))

# Plotting proportion of complaints closed with non-monetary relief
fig4f.add_trace(go.Scatter(x=resolution_per_complaint_df['year'],
                           y=resolution_per_complaint_df['proportion_non_monetary'],
                           mode='lines',
                           name='Non-Monetary Relief'))

fig4f.update_layout(title="Trend of proportion of complaints closed with monetary and non-monetary relief over time",
                   xaxis_title="Year",
                   yaxis_title="Proportion of complaints closed with relief",
                   legend_title="Company Response Type")

# Same as above by Company names
# query_4fb="""
# WITH total_complaints AS (
#     SELECT DATE_TRUNC(date_received, YEAR) as year,
#            company_name,
#            COUNT(*) as total
#     FROM `bigquery-public-data.cfpb_complaints.complaint_database`
#     GROUP BY year, company_name
# ),
# monetary_complaints AS (
#     SELECT DATE_TRUNC(date_received, YEAR) as year,
#            company_name,
#            COUNT(*) as monetary_relief
#     FROM `bigquery-public-data.cfpb_complaints.complaint_database`
#     WHERE company_response_to_consumer = 'Closed with monetary relief'
#     GROUP BY year, company_name
# ),
# non_monetary_complaints AS (
#     SELECT DATE_TRUNC(date_received, YEAR) as year,
#            company_name,
#            COUNT(*) as non_monetary_relief
#     FROM `bigquery-public-data.cfpb_complaints.complaint_database`
#     WHERE company_response_to_consumer = 'Closed with non-monetary relief'
#     GROUP BY year, company_name
# ),
# top_companies AS (
#     SELECT company_name
#     FROM (
#         SELECT company_name,
#                RANK() OVER (ORDER BY SUM(total) DESC) as rank
#         FROM total_complaints
#         GROUP BY company_name
#     )
#     WHERE rank <= 5
# )
# SELECT t.year,
#        t.company_name,
#        m.monetary_relief / t.total as proportion_monetary,
#        n.non_monetary_relief / t.total as proportion_non_monetary
# FROM total_complaints t
# JOIN monetary_complaints m ON t.year = m.year AND t.company_name = m.company_name
# JOIN non_monetary_complaints n ON t.year = n.year AND t.company_name = n.company_name
# JOIN top_companies tc ON t.company_name = tc.company_name
# ORDER BY t.year, t.company_name

# """

# query_job_4fb = client.query(query_4fb)
# resolution_per_compy_complaint_df = query_job_4fb.to_dataframe()

# import plotly.graph_objects as go

# # Create an empty figure
# fig4fb = go.Figure()

# # Loop through each company
# for company in resolution_per_compy_complaint_df['company_name'].unique():
#     # Filter the data for the company
#     company_data = resolution_per_compy_complaint_df[resolution_per_compy_complaint_df['company_name'] == company]

#     # Create a line trace for the monetary proportion with circle markers
#     fig4fb.add_trace(go.Scatter(x=company_data['year'],
#                                 y=company_data['proportion_monetary'],
#                                 mode='lines+markers',
#                                 name=f'{company} (Monetary)',
#                                 line=dict(shape='linear'),
#                                 marker=dict(symbol='circle-dot')))

#     # Create a line trace for the non-monetary proportion with cross markers
#     fig4fb.add_trace(go.Scatter(x=company_data['year'],
#                                 y=company_data['proportion_non_monetary'],
#                                 mode='lines+markers',
#                                 name=f'{company} (Non-Monetary)',
#                                 line=dict(shape='linear'),
#                                 marker=dict(symbol='x-dot')))

# # Set layout and labels
# fig4fb.update_layout(title='Proportion of Monetary and Non-Monetary Complaints by Company',
#                      xaxis_title='Year',
#                      yaxis_title='Proportion')

# # Show the plot
# # fig4fb.show()

# # Top Companies by Number of Complaints recieved
# query_complaint_by_companies="""SELECT COUNT(DISTINCT company_name) AS total_companies,
#        company_name,
#        COUNT(*) AS total_complaints
# FROM `bigquery-public-data.cfpb_complaints.complaint_database`
# GROUP BY company_name
# ORDER BY total_complaints DESC
# LIMIT 10
# """
# query_no_of_companies = """
# SELECT COUNT(DISTINCT company_name) AS total_companies
# FROM `bigquery-public-data.cfpb_complaints.complaint_database`;
# """

# query_complaint_by_companies_b = client.query(query_complaint_by_companies)
# query_complaint_by_companies_df = query_complaint_by_companies_b.to_dataframe()
# query_complaint_by_companies_df.head(10)

# Total Number of Companies
# query_no_of_companies_b = client.query(query_no_of_companies)
# query_no_of_companies_df = query_no_of_companies_b.to_dataframe()
# query_no_of_companies_df.head()

#"""Insights:
#Based on the data you provided, some initial insights might include:
#
#- BANK OF AMERICA: This bank has been showing a consistent increase in the proportion of monetary complaints, reaching a peak around 2021 and then declining. Non-monetary complaints have been relatively stable.
#- EQUIFAX, INC.: The proportion of monetary complaints is extremely low, almost negligible. Non-monetary complaints peaked around 2019 and then declined sharply.
#- Experian Information Solutions Inc.: This company has a low proportion of monetary complaints, but the non-monetary complaints are relatively high, with significant variations over the years.
#- TRANSUNION INTERMEDIATE HOLDINGS, INC.: There's a noticeable increase in non-monetary complaints in 2022.
#- WELLS FARGO & COMPANY: The company has shown a general trend of decreasing monetary complaints and increasing non-monetary complaints.
#
#These trends over time, show how the companies' responses to complaints have evolved. This information could be valuable for assessing customer satisfaction, regulatory compliance, or other aspects of business performance.
#"""

# 4b: analyzing types of company responses over time
# Query
query4b = """
    SELECT DATE(date_received) as date_received, company_response_to_consumer, COUNT(*) as count
    FROM `bigquery-public-data.cfpb_complaints.complaint_database`
    WHERE company_response_to_consumer IS NOT NULL
    GROUP BY date_received, company_response_to_consumer
    ORDER BY date_received
"""
# Execute the query
query_job = client.query(query4b)
responses_over_time = query_job.to_dataframe()

# Pivot table for better data structure
pivot_response_df = responses_over_time.pivot(index='date_received', columns='company_response_to_consumer', values='count').fillna(0)
pivot_response_df_mva = pivot_response_df.rolling(window=30).mean()  # Monthly moving average

# Create the plot
fig4b = go.Figure()
for col in pivot_response_df_mva.columns:
    if str(col).lower() != 'nan':
        fig4b.add_trace(go.Scatter(x=pivot_response_df_mva.index, y=pivot_response_df_mva[col], mode='lines', name=col))
fig4b.update_layout(title="Trend in Company Responses Over Time (Moving Average)",
                   xaxis_title="Date Received",
                   yaxis_title="Number of Responses (Moving Average)",
                   legend_title="Company Response Type")

# fig4b.show()

# Query
query4c = """
    SELECT DATE(date_received) as date_received, product, COUNT(*) as count
    FROM `bigquery-public-data.cfpb_complaints.complaint_database`
    WHERE product IS NOT NULL
    GROUP BY date_received, product
    ORDER BY date_received
"""
# Execute the query
query_job = client.query(query4c)
product_complaints_over_time = query_job.to_dataframe()

# Pivot table for better data structure
pivot_df = product_complaints_over_time.pivot(index='date_received', columns='product', values='count').fillna(0)
pivot_df_mva = pivot_df.rolling(window=30).mean()  # Monthly moving average

# # Create the plot
# fig4c = go.Figure()
# for col in pivot_df_mva.columns:
#     if str(col).lower() != 'nan':
#         fig4c.add_trace(go.Scatter(x=pivot_df_mva.index, y=pivot_df_mva[col], mode='lines', name=col))
# fig4c.update_layout(title="Trend in Complaints by Product Over Time (Moving Average)",
#                    xaxis_title="Date Received",
#                    yaxis_title="Number of Complaints (Moving Average)",
#                    legend_title="Product")

# fig4c.show()

# 4d: analyzing complaints by issue over time
# Query
query4d = """
    SELECT EXTRACT(YEAR FROM date_received) as year, issue, COUNT(*) as count
    FROM `bigquery-public-data.cfpb_complaints.complaint_database`
    GROUP BY year, issue
    ORDER BY year, count DESC
"""
# Execute the query
query_job = client.query(query4d)
issue_complaints_over_time = query_job.to_dataframe()

# Replace missing issue values with 'Unknown'
issue_complaints_over_time['issue'] = issue_complaints_over_time['issue'].fillna('Unknown')

# Getting the issue with max complaints for each year
issue_complaints_over_time = issue_complaints_over_time.loc[issue_complaints_over_time.groupby('year')['count'].idxmax()]

# Creating the plot
fig4d = px.bar(issue_complaints_over_time, x='year', y='count',
             color='issue',
             title='Issue with the highest number of complaints by year',
             labels={'year':'Year', 'count':'Number of Complaints', 'issue':'Issue Type'})

# fig4d.show()

#Data Preparation for Page 5
# Question 5b: Outcome Impact: Does the resolution method, whether monetary or nonmonetary relief, influence the likelihood of a customer dispute?

# Query
query5a = """
    SELECT company_response_to_consumer, COUNT(*) as count
    FROM `bigquery-public-data.cfpb_complaints.complaint_database`
    WHERE company_response_to_consumer IS NOT NULL
    GROUP BY company_response_to_consumer
"""
# Execute the query
query_job = client.query(query5a)
response_counts_pandas_df = query_job.to_dataframe()

# Replace missing issue values with 'Unknown'
response_counts_pandas_df['company_response_to_consumer'] = response_counts_pandas_df['company_response_to_consumer'].fillna('Unknown')

# Creating the plot
fig5a = px.pie(response_counts_pandas_df,
             values='count',
             names='company_response_to_consumer',
             title='Composition of Different Company Response Types')

# Changing the pie chart to donut chart by adding a hole parameter
fig5a.update_traces(hole=.3)

# fig5a.show()

# 5b: How does Company's response impact the dispute rate
# List of required responses
required_responses = [
    'Closed',
    'Closed with explanation',
    'Closed with monetary relief',
    'Closed with non-monetary relief'
]

# Query
query5b = """
    SELECT company_response_to_consumer as Response, consumer_disputed as Dispute, COUNT(*) as Count_response
    FROM `bigquery-public-data.cfpb_complaints.complaint_database`
    WHERE company_response_to_consumer IS NOT NULL
    AND company_response_to_consumer IN UNNEST(@required_responses)
    GROUP BY Response, Dispute
"""
query_params = [
    bigquery.ArrayQueryParameter("required_responses", "STRING", required_responses)
]

# Execute the query
job_config = bigquery.QueryJobConfig()
job_config.query_parameters = query_params
query_job = client.query(query5b, job_config=job_config)

filtered_df = query_job.to_dataframe()

# display(filtered_df)

# Filter out NA in disputes
filtered_df = filtered_df[filtered_df['Dispute'].notna()]

# Change boolean values to string representation
filtered_df['Dispute'] = filtered_df['Dispute'].apply(lambda x: 'True' if x else 'False')

# Plotting
fig5b = px.pie(filtered_df,
             values='Count_response',
             names='Dispute',
             color='Dispute',
             title='Percentage of Disputes and Non-Disputes for Each Response Type',
             facet_col='Response',
             facet_col_wrap=2,
             color_discrete_map={'True': '#DC3912', 'False': '#2CA02C'})

fig5b.update_traces(textinfo='percent+label',
                    insidetextorientation='radial',
                    textposition='inside')

# fig5b.show()

# summary_stats = filtered_df.groupby('Response').apply(lambda x: x[x['Dispute'] == 'True']['Count_response'].sum() / x['Count_response'].sum() * 100).reset_index()
# summary_stats.columns = ['Response', 'Dispute_Percentage']
# print(summary_stats)

# Exclude NA in disputes
filtered_df = filtered_df[filtered_df['Dispute'].notna()]

# Map monetary and non-monetary responses
filtered_df['Monetary'] = filtered_df['Response'].map({
    'Closed with monetary relief': 'Monetary',
    'Closed with non-monetary relief': 'Non-Monetary',
    'Closed': 'Non-Monetary', # Adjust these as appropriate
    'Closed with explanation': 'Non-Monetary'
})

# Create a contingency table
contingency_table_monetary = filtered_df.pivot_table(index='Monetary', columns='Dispute', values='Count_response', aggfunc='sum', fill_value=0)

# Perform chi-squared test
# chi2_5, p_5, dof_5, expected_5 = chi2_contingency(contingency_table_monetary)
# print("Chi-squared Statistic for dispute rates for monetary/non-monetary:", chi2_5)
# print("p-value:", p_5)

from scipy.stats import fisher_exact

odds_ratio, p_value = fisher_exact(contingency_table_monetary)
print(f"Odds Ratio for monetary vs non-monetary responses: {odds_ratio}")
print(f"p-value: {p_value}\n")

"""**Interpretation: Fisher's Exact Test**

**Odds Ratio: 2.0969**
The odds ratio measures the strength and direction of the association between the two variables. An odds ratio of 2.0969 means that the odds of a dispute occurring are approximately 2.10 times higher for non-monetary responses compared to monetary responses.

**p-value: 0.0**
Similar to the chi-squared test, this p-value tells you that the association between monetary/non-monetary responses and dispute rates is highly statistically significant.
"""

import requests
import pickle


url = "https://github.com/monicacs5830/CFPB_Analysis/raw/main/Complement_NB_model.pkl"
response = requests.get(url)
Complement_NB = pickle.loads(response.content)

# Load the test dataset
Narrative_test_set = pd.read_csv('https://raw.githubusercontent.com/AliHaghighat1/Consumer-Complaints/main/Narrative_test.csv')

# !pip list command

# Initializing Dashboard
app = dash.Dash(__name__, external_stylesheets=[dbc.themes.SUPERHERO], suppress_callback_exceptions=True)
server=app.server
# Button style with padding
button_style = {'margin': '20px', 'margin-left': '20px', 'margin-right': '20px'}
# Heading stype with padding
heading_style = {'margin': '15px', 'margin-left': '10px', 'margin-right': '10px'}

# Defining the footer
footer = dbc.Container(
    [
        html.Hr(),  # Add a horizontal line
        dbc.Row(
            [
                html.P("For More Information Click on the GitHub Link here:", style={'textAlign': 'center'}),
                dbc.Col(
                    html.A(
                        html.Img(src='https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png', height="40px"),
                        href="https://github.com/monicacs5830/CFPB_Complaints_Analysis"
                    ),
                    style={'textAlign': 'center'}
                ),
            ],
            align="center",  # Center the contents vertically
            justify="center",  # Center the contents horizontally
        ),
    ],
    fluid=True
)

# defining the sidebar
sidebar = dbc.Nav(
    [
        dbc.NavLink("Home", href="/", active="exact"),
        dbc.NavLink("Products and Subproducts Distribution", href="/page-1", active="exact"),
        dbc.NavLink("Issues and Subissues Distribution", href="/page-2", active="exact"),
        dbc.NavLink("Complaints by Submission Method", href="/page-3", active="exact"),
        dbc.NavLink("Trends in Complaints in CFPB", href="/page-4", active="exact"),
        dbc.NavLink("Outcome Impact Analysis", href="/page-5", active="exact"),
        dbc.NavLink("Prediction of Company's Response", href="/page-6", active="exact"),
        dbc.NavLink("Summary of Findings and References", href="/page-7", active="exact"),
    ],
    vertical="md",
    pills=True,
    id='sidebar',
)
# definind the navbar
navbar = dbc.Navbar(
    dbc.Container(
        dbc.Row(
            [
                dbc.Col(
                    dbc.NavbarBrand(
                        html.Img(src="https://cfpb.github.io/design-system/images/uploads/logo_background_photo.png",
                                 style={'width':'130%', 'height':'90%'}),
                        className="ml-2",
                        style={'height': '90%', 'width':'130%'}
                    ),
                    width=12,
                    align="start"
                ),
                dbc.Col(
                    dbc.Button(
                        "Menu",
                        id="btn_sidebar",
                        n_clicks=0,
                        className="mr-2",
                        style={'margin':'20px'},
                    ),
                    width="auto",
                    align="end"
                ),
            ],
            align="center",
            justify="between",
        ),
        fluid=True,
    ),
    color="light",  # Changed to light
    dark=False,  # Set to false for a light navbar
    className="mb-4",
)




# Put sidebar inside a dbc.Collapse
sidebar_collapse = dbc.Collapse(sidebar, id="collapse")

# Layouts

# Using BigQuery to pull data into a Pandas DataFrame for initial exploration
query = """
SELECT *
FROM `bigquery-public-data.cfpb_complaints.complaint_database`
LIMIT 5
"""
#
sample_data = client.query(query).to_dataframe() # limit data to 5 rows and convert to pandas

# Defining the homepage with introduction, sample data and buttons
homepage = html.Div([
    html.H1(" Understanding Financial Complaint Outcomes : A Data-Driven Approach", style= heading_style),
#     html.Br(),
    html.Img(src='https://www.centralbank.ie/images/default-source/consumer-hub/explainers---banner-images/complaints-banner.jpg?sfvrsn=4',
             style={'display':'block','width':'60%', 'height':'20%', 'margin-left': 'auto', 'margin-right': 'auto'}),
    html.Br(),
    html.P("""
    The financial industry plays a key role in supporting personal and business financial goals.
    Like any sector, it sees its fair share of customer dissatisfaction, which, when analyzed, can offer crucial feedback and insights into customer expectations and problem areas.
    This project aims to analyze financial product complaints, predict their outcomes, and uncover insights into consumer behavior and possible improvements for financial services.
    """),
    html.H2("Dataset"),
    html.Br(),
    html.Br(),
    html.P("""
    We use the Consumer Financial Protection Bureau (CFPB) Complaint Database, hosted on Google's BigQuery public datasets.
    This 2.15GB dataset consists of over 3.4 million rows of data on consumer complaints related to financial products and services reported to the CFPB from 2011 to 2023.
    Key variables include 'date_received', 'product', 'issue', 'consumer_complaint_narrative', 'company_name', 'state', 'company_response_to_consumer', 'timely_response', and 'consumer_disputed'.
    The latter two will serve as response variables for complaint distribution and satisfaction analysis.
    """),
    html.Br(),
    html.H5("Below is a snapshot of our data:"),
    dbc.Card(
        dbc.CardBody(
            dash_table.DataTable(
                id='table',
                columns=[{"name": i, "id": i} for i in sample_data.columns],
                data=sample_data.to_dict('records'),
                style_cell={'color': 'black'} ,
                style_table={'overflowX': 'auto'},  # Enable horizontal scrolling
            ),
        ), style={'margin': '20px'}, className= "bg-primary mb-3"
    ),
    html.Br(),
    dbc.Container(
        dbc.Row(
            html.Div(className='nav-buttons', children=[
                dbc.Button("Next Section", color="primary", href='/page-1', className="mr-1"),
            ], style={'textAlign': 'center', 'margin': '20px'}), justify='center'
        ), fluid=True
    ),
])
# Layout for page 1
page_1 = html.Div([
#     dcc.Link('Go to Home', href='/'),
    html.Br(),
    html.H3("Complaint Distribution"),
    html.Br(),
    html.H4("How are complaints distributed by product and sub-product? Is there any variation in this distribution by state?"),
    html.Br(),
    dcc.Graph(figure=fig1a),
    html.Br(),
    html.P("The graph illustrates complaint numbers for different financial product categories. 'Credit reporting, credit repair services, or other personal consumer reports' received the most complaints (1.6 million), indicating consumer issues. 'Debt collection' followed with over 0.4 million complaints, reflecting challenges faced with debt collectors. 'Mortgage' had just below 0.4 million complaints, unsurprising due to its significant financial commitment. Other categories had fewer complaints, all below 0.2 million counts, suggesting fewer issues compared to credit reporting, debt collection, and mortgages. Interestingly, 'virtual currency' had the fewest complaints, implying relative consumer satisfaction. The graph offers valuable insights for companies and regulators to enhance consumer experiences and address potential issues effectively."),
    html.Br(),
    html.P("""
    Products and sub-products in the dataset correspond to the types of financial services that the complaints are about. For example, the product could be "Mortgage" and the sub-product could be "Federal Housing Administration (FHA) mortgage".
    Products and sub-products essentially help us understand which financial services or aspects of a service the consumer had issues with.
    """),
    html.Br(),
    html.H4("Interactive Choropleth Map of Complaint Types by State"),
    html.Br(),
    html.H5("Select a Product:"),
    dcc.Dropdown(
        id='product-dropdown',
        options=[{'label': product, 'value': product} for product in products],
        value=products[0],
        style={'color': '#000', 'background-color': '#fff'}
    ),
    html.Br(),
    html.H5("Select a Subproduct:"),
    dcc.Dropdown(
        id='subproduct-dropdown',
        style={'color': '#000', 'background-color': '#fff'}
    ),
    html.Br(),
    dcc.Graph(id='choropleth-graph'),
    html.Br(),
    html.Br(),
    html.P(""" The choropleth map above provides an insightful visualization of consumer complaints across the United States, segmented by both product and subproduct
    categories. By allowing users to select specific products and subproducts of interest, they can analyze and compare complaint distributions in different states.
    This valuable information empowers each state to address consumer concerns more effectively and prioritize resources to tackle the most prevalent issues.
    Understanding which products and subproducts receive the most complaints in each state is essential for improving consumer protection and promoting better
    customer experiences nationwide.
    Among all product types, credit reporting complaints are most prevalent in Florida (FL), making it the state with the highest number of such complaints.
    Following closely behind is Texas (TX), which ranks second in terms of credit reporting complaints for the same product type.
    Conversely, Virginia (VA) exhibits the lowest number of complaints related to the product of virtual currency, reflecting a relatively low incidence of consumer
    concerns in this category. Similarly, Wyoming has the lowest number of complaints concerning the subproduct of Lease, indicating a minimal frequency of issues reported in this specific area.
    """),
    html.Br(),
    html.P("These insights are crucial for financial companies and local & state authorities so that they can target these products as areas for improvements in customer services. "),
    html.Br(),
    dbc.Container(
        dbc.Row(
            html.Div(className='nav-buttons', children=[
#                 dbc.Button("Previous Section", color="primary", href='/page-1', className="mr-1"),
                dbc.Button("Home", color="primary", href='/', className="mr-1"),
                dbc.Button("Next Section", color="primary", href='/page-2', className="mr-1", style={'margin-left': '20px'}),
            ], style={'textAlign': 'center', 'margin': '20px'}), justify='center'
        ), fluid=True
    ),
])

# Layout for page 2
page_2 = html.Div([
#     dcc.Link('Go to Home', href='/'),
    html.Br(),
    html.H3("Issue Prevalence"),
    html.Br(),
    html.H4("What are the most frequently mentioned issues and sub-issues in the complaints?"),
    html.Br(),
    html.H4("Interactive Plot for Distribution of Issue Types"),
    html.Br(),
    html.H5("Select an Issue:"),
    dcc.Dropdown(
        id='issue-dropdown',
        options=[{'label': issue, 'value': issue} for issue in issues],
        value=issues[0],
        style={'color': '#000', 'background-color': '#fff'}
    ),
    dcc.Graph(id='bar-graph'),
    dcc.Graph(figure=fig2b),
    html.Br(),
    html.P("""
    Issues and sub-issues refer to the specific problems that consumers encountered with those products or sub-products.
    For example, within the product category "Mortgage", an issue might be "Struggling to pay mortgage".
    A sub-issue could further specify the problem, such as "Trouble during payment process".
    """),
    html.Br(),
    html.P("""Based on the graph, an analysis of the distribution of complaints across various issue and subissue categories reveals the following key findings:"""),
    html.Ul([
    html.Li("Among all the issues, the most common complaint category was \"incorrect information on one's report,\" with a significant count of 800,000 complaints. This suggests that a large number of consumers faced challenges due to inaccuracies in their credit reports."),
    html.Li("The second most prevalent issue was related to credit reporting companies' investigations into existing problems, which garnered over 400,000 complaints. Consumers expressed concerns about the effectiveness and thoroughness of these investigations."),
    html.Li("Another prominent issue was the \"improper use of the report,\" with more than 300,000 complaints. This indicates that consumers encountered instances where their credit reports were utilized inappropriately."),
    html.Li("Furthermore, the issue of \"attempting to collect debt not owed\" received significant attention, with more than 100,000 complaints. This suggests that a considerable number of consumers faced collection attempts for debts they did not owe."),
    html.Li("On the other end of the spectrum, the issue with the least number of complaints was related to \"written notification about debt,\" with less than 100,000 complaints. This issue seems to have affected relatively fewer consumers compared to other problems."),
    html.Li("Examining subissues within the category of \"incorrect information on the report,\" complaints primarily revolved around \"information belonging to someone else,\" accounting for over 500,000 complaints. Additionally, there were notable complaints about \"incorrect account information\" and \"incorrect status\" on credit reports, with 99,000 and 98,000 complaints, respectively."),
    html.Li("Conversely, the subissue of \"incorrect personal information\" received the least number of complaints, with only 50,000 reported cases."),
    html.Li("In summary, the graph's analysis sheds light on the most prevalent issues and subissues faced by consumers, emphasizing the importance of addressing inaccuracies in credit reports and the need for improved practices by credit reporting companies."),
]),
    html.Br(),
    dbc.Container(
        dbc.Row(
            html.Div(className='nav-buttons', children=[
                dbc.Button("Previous Section", color="primary", href='/page-1', className="mr-1"),
                dbc.Button("Home", color="primary", href='/', className="mr-1", style={'margin-left': '20px'}),
                dbc.Button("Next Section", color="primary", href='/page-3', className="mr-1", style={'margin-left': '20px'}),
            ], style={'textAlign': 'center', 'margin': '20px'}), justify='center'
        ), fluid=True
    ),
])

#Layout for page 3
page_3 = html.Div([
#     dcc.Link('Go to Home', href='/'),
    html.Br(),
    html.H3("Submission Method Impact"),
    html.Br(),
    html.H4("Is there any relationship between the method used to submit the complaint and the response from the company or the outcome of the dispute? "),
    html.Br(),
    dcc.Graph(figure=fig3),
    html.Br(),
    html.Ul([
    html.Li("According to the graph above, it illustrates the number of company responses to complaints, categorized by different methods of complaint submission. The submission method that received the highest number of company responses was through the web."),
    html.Li("For all types of submission methods, the most common company response was to close the complaints with an explanation. This indicates that a significant proportion of complaints were resolved by providing consumers with a detailed explanation of the actions taken or the reasons behind the issues raised."),
    html.Li("However, there were notable issues with certain submission methods. Specifically, complaints submitted via referral, phone, postal mail, fax, web referral or email had low numbers of responses from the company. This highlights a concerning lack of responsiveness from companies to complaints submitted through these channels."),
    ]),
    html.P("In summary, although web submissions were the most common method for consumers to submit complaints, there was no conclusive evidence to suggest a significant relationship between the method of submission and the response from the company. To reinforce these findings, we performed a chi-squared test of independence."),
    html.Br(),
    html.H5("Chi-Square Analysis of Complaint Submission Method and Company Response"),
    html.Br(),
    html.P("""
    The Chi-squared test of independence is a statistical hypothesis test used to determine if there is a significant association between two categorical variables in a sample.
    In this context, we performed the Chi-squared test to check if there is any significant relationship between the method of complaint submission (such as through the web, phone, mail, etc.) and the response from the company (like closing with explanation, monetary relief, etc.).
    """),
    html.Br(),
    html.P("""
    Here are the steps involved:
    """),
    html.Ul([
    html.Li("We first construct a contingency table that cross-tabulates the two categorical variables (submission method and company response in this case)."),
    html.Li("The test then calculates a chi-square statistic, which measures the difference between the observed frequencies of responses in each category and the frequencies we would expect to see if there was no association between the two variables (i.e., if they were independent)."),
    html.Li("The p-value associated with this statistic is then computed. The p-value is the probability of observing a chi-square statistic as extreme as the one calculated (or more extreme) if the null hypothesis is true."),
    ]),
    html.Br(),
    html.Ul([
    html.Li("Null Hypothesis: There is no significant relationship between the two variables"),
    html.Li("Alternative Hypothesis: There is a significant relationship."),
        ]),
    html.Br(),
    html.Div(id='chi-square-test'),
    html.Br(),
    html.P("""
    The p-value indicates the probability of observing a chi2 statistic as extreme as the one calculated (or more extreme) under the null hypothesis. If the p-value is less than the significance level (typically 0.05), we reject the null hypothesis and conclude that there is a significant relationship between the submission method and the company response.
    In the above case, p-value is high (0.99), which means we fail to reject the null hypothesis. This suggests that there's no statistically significant relationship between the method used to submit the complaint (submitted_via) and the response from the company (company_response_to_consumer)."""),
    html.Br(),
    dbc.Container(
        dbc.Row(
            html.Div(className='nav-buttons', children=[
                dbc.Button("Previous Section", color="primary", href='/page-2', className="mr-1"),
                dbc.Button("Home", color="primary", href='/', className="mr-1", style={'margin-left': '20px'}),
                dbc.Button("Next Section", color="primary", href='/page-4', className="mr-1", style={'margin-left': '20px'}),
            ], style={'textAlign': 'center', 'margin': '20px'}), justify='center'
        ), fluid=True
    ),
])

complaints_over_time['date_received'] = pd.to_datetime(complaints_over_time['date_received'])
complaints_over_time = complaints_over_time[complaints_over_time['date_received'].dt.year >= 2012]

# Layout for page 4
page_4_layout = html.Div([
    html.Br(),
    html.H3("Trend Identification"),
    html.Br(),
    html.H4("Can we discern any trends in how the CFPB handles cases or how companies respond over time? Are there unusually high instances of responses for any specific product or issue category?"),
    html.Br(),
    html.H4("Analyzing total complaints over time"),
    dcc.Slider(
    id='year-slider',
    min=complaints_over_time['date_received'].min().year,
    max=complaints_over_time['date_received'].max().year,
    value=complaints_over_time['date_received'].min().year,
    marks={str(year): str(year) for year in complaints_over_time['date_received'].dt.year.unique()},
    step=None
    ),
    dcc.Graph(
        id='graph_4a'
    ),
    html.Br(),
    html.P("""
    The above graph portrays a consistent pattern of complaints over time, followed by a significant increase in recent years, reaching a peak in 2023.
    This trend could indicate various factors influencing consumer experiences or a potential rise in consumer awareness and reporting during that period.
    Further analysis would be required to understand the drivers behind this notable shift in complaint volumes."""),
    html.Br(),
    html.Br(),
    html.H4("Analyzing total complaints and complaints closed with monetary and non-monetary relief over time"),
    dcc.Graph(
        figure=fig4f
    ),
    html.Br(),
    html.Ul([
    html.Li("Decrease in Monetary Relief: The steady decrease in monetary relief might indicate an industry shift towards resolving complaints through other means, such as offering services, discounts, or other non-cash resolutions."),
    html.Li("Non-Monetary Relief Peak in 2022: The significant increase in non-monetary relief in 2022 could reflect a specific event, regulation change, or trend in consumer behavior. Further investigation might reveal the underlying cause."),
    html.Li("2023 Data Interpretation: If the 2023 data is partial (only up to the current date), this might explain the lower proportions for both monetary and non-monetary relief, and it might not represent a real change in trend."),
        ]),
    html.Br(),
    html.H4("Analyzing Company Responses Over Time"),
    dcc.Graph(figure=fig4b),
    html.Br(),
    html.P("""The graph above highlights the trends in company responses to consumer complaints over the years.
    While some response categories remained relatively stable, there were significant changes in others, indicating evolving practices and a potential focus on more thorough explanations and non-monetary remedies in recent times.
    The data offers valuable insights into how companies addressed consumer complaints and grievances during this decade-long period."""),
    html.Br(),
    html.H4("Analyzing Complaints by Product Types Over Time"),
    dcc.Dropdown(
        id='dropdown_4c',
        options=[
            {'label': i, 'value': i} for i in pivot_df_mva.columns
        ],
        value=pivot_df_mva.columns[0],
        style={'color': '#000', 'background-color': '#fff'}
    ),
    dcc.Graph(
        id='graph_4c'
    ),
    html.H4("Analyzing issues over time"),
    dcc.Graph(figure=fig4d),
    html.Br(),
    html.Ul([
    html.Li("Over the period from 2012 to 2023, there has been a general upward trend in the number of complaints across various products, including debt collection, money transfer, virtual currency, money service, different types of loans, and vehicle loan or lease."),
    html.Li("However, it's important to note that for some issues, such as money transfers, the available data only spans from 2013 to 2017, limiting our ability to gain meaningful insights beyond that time frame."),
    html.Li("In the case of mortgage-related complaints, the numbers have remained relatively stable since 2012, with a slight increase observed in 2013."),
    html.Li("For other products, the increasing trend suggests a growing concern among consumers regarding these services."),
    html.Li("To draw more comprehensive conclusions and identify potential patterns, it is essential to have complete data throughout the entire time range."),
    html.Li("Nonetheless, this information provides valuable insights into the shifting landscape of consumer complaints and highlights the importance of continually monitoring and addressing consumer concerns across different products and industries."),
    ]),
    html.Br(),
    dbc.Container(
        dbc.Row(
            html.Div(className='nav-buttons', children=[
                dbc.Button("Previous Section", color="primary", href='/page-3', className="mr-1"),
                dbc.Button("Home", color="primary", href='/', className="mr-1", style={'margin-left': '20px'}),
                dbc.Button("Next Section", color="primary", href='/page-5', className="mr-1", style={'margin-left': '20px'}),
            ], style={'textAlign': 'center', 'margin': '20px'}), justify='center'
        ), fluid=True
    ),
])

# Layout for Page 5
page_5_layout = html.Div([
#     dcc.Link('Go to Home', href='/'),
    html.Br(),
    html.H3("Outcome Impact"),
    html.Br(),
    html.H4("Does the resolution method, whether monetary or nonmonetary relief, influence the likelihood of a customer dispute?"),
    html.Br(),
    dcc.Graph(id='page-5-graph-a', figure=fig5a),
    html.Br(),
    html.P("""
    The above graph indicates that the majority of consumer complaints received thorough attention through explanations from companies, while a notable portion received non-monetary relief.
    The relatively low percentage of complaints closed with monetary relief suggests that financial compensation was not the primary resolution approach.
    Additionally, the presence of complaints still "in progress" underscores the ongoing efforts to address consumer concerns.
    Overall, the data provides valuable insights into how companies handled various types of consumer complaints."""),
    html.Br(),
    dcc.Graph(id='page-5-graph-b', figure=fig5b),
    html.Br(),
    html.P("""From the above graph, it can be observed that complaints resolved with monetary relief have a lower likelihood of resulting in a dispute compared to other resolution methods (11.3%).
    Conversely, complaints closed with explanation or simply closed have relatively higher dispute rates (24.2% and 26.5%, respectively). To further reinforce these findings, we performed fisher's exact test.
    """),
    html.Br(),
    html.Br(),
    html.H5("Fisher's Exact Distance to determine whether the odds of disputes occuring for non-monetary to that of monetary response."),
    html.Br(),
    html.Div(id='fishers-exact-test'),
    html.P("""The odds ratio measures the strength and direction of the association between the two variables. An odds ratio of 2.0969 means that the odds of a dispute occurring are approximately 2.10 times higher for non-monetary responses compared to monetary responses."""),
    html.Br(),
    dbc.Container(
        dbc.Row(
            html.Div(className='nav-buttons', children=[
                dbc.Button("Previous Section", color="primary", href='/page-4', className="mr-1"),
                dbc.Button("Home", color="primary", href='/', className="mr-1", style={'margin-left': '20px'}),
                dbc.Button("Next Section", color="primary", href='/page-6', className="mr-1", style={'margin-left': '20px'}),
            ], style={'textAlign': 'center', 'margin': '20px'}), justify='center'
        ), fluid=True
    ),
])

# Layout for Page 6
page_6_layout = html.Div([
    dbc.Container(
        dbc.Row(
            [
                html.H3("The Company's Response Prediction Based On the Consumer Narrative", className="text-center"),
                html.P("The initial narrative is selected randomly from the test dataset when you click the Generate Prediction button below. The user can customize these narratives and generate a prediction for the same.", className="text-center"),
                dbc.Button("Generate Prediction", id="prediction-button", className="mr-1", style={'margin': '20px'}),
            ], className="py-5 text-center"
        ), fluid=True
    ),
    dbc.Container(
        [
            dbc.Row(
                [
                    dbc.Col(
                        dbc.Card(
                            [
                                dbc.CardHeader(
                                    html.H4("Consumer Narrative", className="card-title"),
                                ),
                                dbc.CardBody(
                                    [
                                        dcc.Textarea(id="narrative", className="card-text", value="No Narrative yet", style={'width': '100%', 'height': 200}),
                                        ]
                                    )
                            ], className="text-black bg-light mb-3"
                        ), md=4
                    ),
                    dbc.Col(
                        dbc.Card(
                            [
                                dbc.CardHeader(
                                    html.H4("Predicted Response", className="card-title"),
                                ),
                                dbc.CardBody(
                                    [
                                        html.H5(id="prediction", className="card-text"),
                                    ]
                                )
                            ], className="text-black bg-light mb-3"
                        ), md=4
                    ),
                    dbc.Col(
                        dbc.Card(
                            [
                                dbc.CardHeader(
                                    html.H4("Probability Of The Response", className="card-title"),
                                ),
                                dbc.CardBody(
                                    [
                                        html.H5(id="prob_max", className="card-text"),
                                    ]
                                )
                            ], className="text-black bg-light mb-3"
                        ), md=4
                    ),
                ]
            ),
        ], fluid=True
    ),
    #dbc.Button("Generate prediction", id="prediction-button", className="mr-1", style={'margin': '20px'}),
    html.Br(),
    html.P("In our project, we built a machine learning model to predict if a company's response to a complaint is monetary or non-monetary. We also calculated the probability of the response. The final model used the SVM classifier, achieving a baseline accuracy of 86%."),
    html.Br(),
    html.H5("Here's how we refined our models:"),
    html.Ul([
        html.Li([
            html.H5("Data Selection: "),
            html.P("We selected data where the company's response was 'Closed with monetary relief' or 'Closed with non-monetary relief'. These categories were chosen for their practicality and balance, allowing for more accurate predictions. Data without company narratives or with 'Closed with explanation' responses were excluded.")
        ]),
        html.Li([
            html.H5("Feature Selection: "),
            html.P("Leveraging our understanding of the domain, we focused on the features that provided rich information, such as the complaint narratives column.")
        ]),
        html.Li([
            html.H5("Feature Combinations: "),
            html.P("We tested various combinations of features to find the most predictive set, gaining insights into variable relationships and patterns.")
        ]),
        html.Li([
            html.H5("Optimization with Pipelines: "),
            html.P("We optimized the modeling process using pipelines, efficiently fine-tuning our models for alignment with the data.")
        ]),
        html.Li([
            html.H5("Vectorizer Analysis: "),
            html.P("We assessed different vectorization techniques, selecting the best methods to translate textual data into numerical form, tailoring them to our specific needs.")
        ]),
    ]),
    html.Br(),
    html.P("These targeted measures contributed to the refinement and success of our machine learning models, resulting in an approach that accurately and meaningfully interprets complaint narratives."),
    html.Br(),
    dbc.Container(
        dbc.Row(
            html.Div(className='nav-buttons', children=[
                dbc.Button("Previous Section", color="primary", href='/page-5', className="mr-1"),
                dbc.Button("Home", color="primary", href='/', className="mr-1", style={'margin-left': '20px', 'margin-right': '20px'}),
                dbc.Button("Next Section", color="primary", href='/page-7', className="mr-1"),
            ], style={'textAlign': 'center', 'margin': '20px'}), justify='center'
        ), fluid=True
    ),
])


# Layout for Page 7
page_7_layout = html.Div([
    dbc.Container([
        html.H3("Summary of Findings", className="text-center"),
        html.P(
            """In conclusion, our project aimed to gain a comprehensive understanding of customer disputes in financial product complaints and develop a predictive model for consumer complaints. We simultaneously sought to reveal crucial insights into consumer behavior, major pain points, and areas for improvement in financial services."""
        ),
        html.P(
            """Utilizing a diverse set of methods and techniques, including EDA, NLP, Time Series Analysis, Docker, and MapReduce, we explored and forecasted financial product complaints using the CFPB dataset."""
        ),
        html.P("Key findings include:"),
        html.Ul([
          html.Li("There was no relationship between submission method and response type."),
          html.Li("The number of complaints exhibited a consistent increasing trend over recent years."),
          html.Li("Credit reporting-related products received the highest number of complaints, with Florida leading in the frequency of these complaints."),
          html.Li("The most number of complaints relate to the issue of incorrect information on ones report and the sub-issue of the information belonging to someone else."),
          html.Li("Companies were most responsive to complaints submitted through the web."),
          html.Li("There is a need for improvement in handling web referral or email complaints due to low response rates."),
          html.Li("The majority of consumer complaints were resolved with detailed explanations. The proportion of monetary to non-monetary relief was minimal but showed a gradual increase for non-monetary relief in recent years. There is no data to support the reasons for this trend."),
          html.Li("Complaints resolved with monetary or non-monetary reliefs had the lowest likelihood of leading to disputes compared to other resolution methods."),
          html.Li("Our NLP model revealed that when the complaint narratives are well explained, the model predicts the company's response based on user narrative with a baseline accuracy of 86%.")
      ]),
        html.P(
            """While the project provides valuable insights into consumer complaints using the CFPB dataset, it acknowledges a limitation in potentially skewing the model's perspective towards negative customer experiences. Future improvements can focus on capturing non-complaint interactions and positive feedback, offering a more balanced view of consumer experiences and fostering more accurate analyses."""
        ),
        html.P(
            """Future studies have the potential to enhance our project by incorporating more diverse datasets and methodologies beyond the CFPB dataset. By doing so, industries can gain a broader and more comprehensive understanding of customer interactions and experiences, leading to better models for addressing customer complaints and improving overall customer satisfaction in the financial sector."""
        ),
        html.Br(),
        html.Br(),
        html.H3("References", className="text-center"),
        html.Ol([
          html.Li("CFPB Complaints Dataset: Google BigQuery. (2019). Available at: console.cloud.google.com/bigquery?ws=!1m4!1m3!3m2!1sbigquery-public-data!2scfpb_complaints."),
          html.Li("Google BigQuery. (2019). CFPB Complaints Dataset. Available at: console.cloud.google.com/bigquery?ws=!1m4!1m3!3m2!1sbigquery-public-data!2scfpb_complaints"),
          html.Li("Google. (n.d). Google cloud platform. https://console.cloud.google.com/"),
          html.Li("Google. (n.d). Use the Google Cloud console  |  BigQuery. Google. https://cloud.google.com/bigquery/docs/bigquery-web-ui"),
          html.Li("McKinney, W., Perktold, J., & Seabold, S. (2011). Time series analysis in python with statsmodels. Proceedings of the Python in Science Conference. https://doi.org/10.25080/majora-ebaa42b7-012"),
          html.Li("Statistical Data Visualization#. seaborn. (n.d.). https://seaborn.pydata.org/index.html"),
          html.Li("Colab.google. colab.google. (n.d.). https://colab.google/"),
          html.Li("Learn: Machine learning in python - scikit-learn 0.16.1 documentation. scikit. (n.d.). https://scikit-learn.org/"),
          html.Li("Pandas documentation#. pandas documentation - pandas 2.0.3 documentation. (n.d.). https://pandas.pydata.org/docs/index.html"),
          html.Li("Bootstrap 3 Tutorial. (2019). W3schools.com. https://www.w3schools.com/bootstrap/default.asp"),
          html.Li("scikit-learn. (2019). scikit-learn: machine learning in Python. Scikit-Learn.org. https://scikit-learn.org/stable/"),
          html.Li("Dash bootstrap components. Dash Bootstrap Components. (n.d.). https://dash-bootstrap-components.opensource.faculty.ai/"),
          html.Li("Dash overview. Plotly. (n.d.). https://plotly.com/dash/"),
          html.Li("Duran, J. (2021, August 28). Aggregating data with PySpark on GCP. Medium. https://medium.com/mlearning-ai/aggregating-data-with-pyspark-on-gcp-aed527a1e8bc"),
          html.Li("GeeksforGeeks. (2022, December 26). Defining dataframe schema with Structfield and structtype. GeeksforGeeks. https://www.geeksforgeeks.org/defining-dataframe-schema-with-structfield-and-structtype/"),
          html.Li("GoogleCloudDataproc. (n.d.). GoogleCloudDataproc/Cloud-dataproc: Cloud dataproc: Samples and utils. GitHub. https://github.com/GoogleCloudDataproc/cloud-dataproc"),
          html.Li("Krieger, M. (2021, February 28). Callbacks, layouts, &amp; bootstrap: How to create dashboards in plotly dash. Medium. https://towardsdatascience.com/callbacks-layouts-bootstrap-how-to-create-dashboards-in-plotly-dash-1d233ff63e30"),
          html.Li("YouTube. (2022). YouTube. Retrieved July 27, 2023, from https://www.youtube.com/watch?v=lLPdRRy7dfE&amp;list=PL3JVwFmb_BnRKqcbtl2hHL5GIQOHX-sC5."),
          html.Li("Yu Huang, M. D. (2023, June 21). Developing interactive and insightful dashboards with Spark and plotly dash. Medium. https://towardsdatascience.com/developing-interactive-and-insightful-dashboards-with-spark-and-plotly-dash-5c0805341922")
    ]),
        html.Br(),
        dbc.Row(
            html.Div(className='nav-buttons', children=[
                dbc.Button("Previous Section", color="primary", href='/page-6', className="mr-1"),
                dbc.Button("Home", color="primary", href='/', className="mr-1", style={'margin-left': '20px'}),
            ], style={'textAlign': 'center', 'margin': '20px'}), justify='center'
        )
    ], fluid=True)
])



# Updating the page content based on the URL
@app.callback(Output('page-content', 'children'),
              Input('url', 'pathname'))
def display_page(pathname):
    if pathname == '/':
        return homepage
    elif pathname == '/page-1':
        return page_1
    elif pathname == '/page-2':
        return page_2
    elif pathname == '/page-3':
        return page_3
    elif pathname == '/page-4':
        return page_4_layout
    elif pathname == '/page-5':
        return page_5_layout
    elif pathname == '/page-6':
        return page_6_layout
    elif pathname == '/page-7':
        return page_7_layout
    else:
        return dbc.Jumbotron([
            html.H1("404: Not found", className="text-danger"),
            html.Hr(),
            html.P(f"The pathname {pathname} was not recognised...")
        ])

# Callback to toggle sidebar
@app.callback(
    Output("collapse", "is_open"),
    [Input("btn_sidebar", "n_clicks")],
    [State("collapse", "is_open")],
)
def toggle_sidebar(n, is_open):
    if n:
        return not is_open
    return is_open

# Callbacks for page 1
@app.callback(
    Output('subproduct-dropdown', 'options'),
    Input('product-dropdown', 'value')
)
def update_subproduct_dropdown(selected_product):
    subproducts = product_to_subproduct[selected_product]
    return [{'label': subproduct, 'value': subproduct} for subproduct in subproducts]

@app.callback(
    Output('choropleth-graph', 'figure'),
    Input('product-dropdown', 'value'),
    Input('subproduct-dropdown', 'value')
)
def update_graph(selected_product, selected_subproduct):
    df_subproduct = product_subproduct_state_df[(product_subproduct_state_df['product'] == selected_product) & (product_subproduct_state_df['subproduct'] == selected_subproduct)]
    fig1b = go.Figure(data=go.Choropleth(
        locations=df_subproduct['state'],
        z=df_subproduct['Counts_Complaints'],
        locationmode='USA-states',
        colorscale="Magma_r",
        name=f"{selected_product}: {selected_subproduct}"
    ))
    fig1b.update_layout(
        geo_scope='usa')
    return fig1b

# Callbacks for page 2
@app.callback(
    Output('bar-graph', 'figure'),
    Input('issue-dropdown', 'value')
)
def update_graph(selected_issue):
    df_issue = issue_subissue_df[(issue_subissue_df['issue'] == selected_issue)]
    fig2a = px.bar(df_issue, x='subissue', y='count', labels={'subissue':'Sub-Issues', 'count':'Count'})
    fig2a.update_layout(title_text=f"Distribution of sub-issues for {selected_issue}")
    return fig2a

# Callbacks for page 3
@app.callback(
    Output('chi-square-test', 'children'),
    Input('url', 'pathname'),
    methods=['GET']  # Add this line to specify the allowed methods
)
def perform_chi_square_test(pathname):
    if pathname == '/page-3':
        # Create a cross-tabulation (contingency table)
        contingency_table = pd.crosstab(method_df_pd['submitted_via'], method_df_pd['company_response_to_consumer'])

        # Perform the Chi-Square Test of Independence
        chi2, p, dof, expected = chi2_contingency(contingency_table)

#         # Create a Dash DataTable from the contingency table
#         table = dash_table.DataTable(
#             data=contingency_table.reset_index().to_dict('records'),
#             columns=[{'name': i, 'id': i} for i in contingency_table.reset_index().columns]
#         )

        # Test result interpretation
        if p < 0.05:
            interpretation = "The p-value is less than 0.05, we reject the null hypothesis and conclude that there is a significant relationship between the submission method and the company response."
        else:
            interpretation = "The p-value is greater than 0.05, we fail to reject the null hypothesis. This suggests that there's no statistically significant relationship between the method used to submit the complaint (submitted_via) and the response from the company (company_response_to_consumer)."

        # Return formatted string
        return [
            #html.H3("Contingency Table"),
            #table,  # Display the contingency table
            html.Br(),
#             html.H3("Chi-Square Test Result"),
#             html.P(f"Chi2 Statistic: {chi2}, P-value: {p}"),
            html.Div(className="card text-white bg-primary mb-3", style={"max-width": "80rem"}, children=[
            html.Div(className="card-header", children="Chi-Square Test Results"),
            html.Div(className="card-body", children=[
            #html.H4(className="card-title", children="Chi-Square Test Results"),
            html.P(className="card-text", children=f"Chi-square statistic: {chi2}, p-value: {p}, Degrees of freedom: {dof}"),
            html.P("Interpretation: " + interpretation)# Replace X, Y,  with the actual results
        ]),
    ])
        ]
    else:
        return ""

# # Callbacks for page 4
@app.callback(
    Output('graph_4a', 'figure'),
    Input('year-slider', 'value')
)
def update_graph(selected_year):
    filtered_df = complaints_over_time[complaints_over_time['date_received'].dt.year == selected_year]

    return {
        'data': [
            go.Scatter(x=filtered_df['date_received'], y=filtered_df['count'],
            mode='lines',
            name='Actual Frequency of Complaints',
            line=dict(color='lightgrey', width=0.5)),

            go.Scatter(x=filtered_df['date_received'], y=filtered_df['monthly_mva'],
                       mode='lines', name='Monthly Moving Average of Complaints')
        ],
        'layout': go.Layout(title='Trend in complaints received over time for the year ' + str(selected_year))
    }

@app.callback(
    Output(component_id='graph_4c', component_property='figure'),
    [Input(component_id='dropdown_4c', component_property='value')]
)
def update_graph(selected_product):
    fig4c = go.Figure()
    fig4c.add_trace(go.Scatter(x=pivot_df_mva.index, y=pivot_df_mva[selected_product], mode='lines', name=selected_product))
    fig4c.update_layout(
        title=f"Trend in Complaints for {selected_product} Over Time (Moving Average)",
        xaxis_title="Date Received",
        yaxis_title="Number of Complaints (Moving Average)",
        legend_title="Product",
    )
    return fig4c
# Callbacks for page 5
@app.callback(
    Output('fishers-exact-test', 'children'),
    Input('url', 'pathname'),
    methods=['GET']  # Add this line to specify the allowed methods
)
def perform_fisher_exact_test(pathname):
    if pathname == '/page-5':
        # Perform Fisher's exact test
        odds_ratio, p_value = fisher_exact(contingency_table_monetary)

        # Test result interpretation
        if p_value < 0.05:
            interpretation = "The p-value is less than 0.05, we reject the null hypothesis and conclude that the association between monetary/non-monetary responses and dispute rates is highly statistically significant"
        else:
            interpretation = "The p-value is greater than 0.05, we fail to reject the null hypothesis and conclude that the association between monetary/non-monetary responses and dispute rates is not statistically significant"

        # Return formatted string
        return [
            html.Div(className="card text-white bg-primary mb-3", style={"max-width": "80rem"}, children=[
            html.Div(className="card-header", children="Fisher's Exact Test Results"),
            html.Div(className="card-body", children=[
            html.P(className="card-text", children=f"Odds Ratio: {odds_ratio}, p-value: {p_value}"),
            html.P("Interpretation: " + interpretation)
        ]),
    ])
        ]
    else:
        return ""

# Callbacks for page 6
@app.callback(
    [
        Output('narrative', 'value'),  # Target the value attribute
        Output('prediction', 'children'),
        Output('prob_max', 'children'),
    ],
    [
        Input('prediction-button', 'n_clicks'),
    ],
    [
        State('narrative', 'value'),  # Get the current value of the narrative textarea
    ]
)
def generate_prediction(n_clicks, current_narrative):
    if n_clicks is None or n_clicks == 0:  # If the button was never clicked
        # Return some default values
        return "No Narrative yet", "No Prediction yet", "No Probability yet"
    elif n_clicks == 1:  # If it's the first click, generate a random narrative
        random_number = random.randint(0, Narrative_test_set.shape[0] - 1)
        narrative = Narrative_test_set.iloc[random_number, 0]
    else:  # If it's a subsequent click, use the edited narrative
        narrative = current_narrative

    text_to_list = [narrative]
    prediction = Complement_NB.predict(text_to_list)
    prediction = prediction[0]
    prob = Complement_NB.predict_proba(text_to_list)
    prob_max = max(prob[0]) * 100
    prob_max = f"{prob_max:.2f}"

    return narrative, prediction, prob_max


# App layout
app.layout = html.Div(
    [
        dcc.Location(id='url', refresh=False),
        navbar,  # Include navbar at the top
        dbc.Row(
            [
                dbc.Col(sidebar_collapse, width=2),  # Sidebar takes 2/12 width
                dbc.Col(
                    [
                        html.Div(id='page-content', style=heading_style),  # content will take up the rest 10 columns
                        footer,  # include footer at the bottom
                    ],
                    md=10
                ),
            ],
            style={'margin': 0, 'padding': 0}  # remove margins and padding from the row
        ),
    ],
    id='main-div'
)



if __name__ == '__main__':
    app.run_server(host='0.0.0.0', port=8080, debug=True)
#    app.run_server(debug=True)

#Launch http://127.0.0.1:8050 on your browser
